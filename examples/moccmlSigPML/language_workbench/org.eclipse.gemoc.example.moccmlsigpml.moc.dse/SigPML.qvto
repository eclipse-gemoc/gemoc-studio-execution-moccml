import org.eclipse.gemoc.moccml_mapping.EclQVToHelper;
modeltype Ecore uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype inMM1 uses 'http://org.eclipse.gemoc.example.moccmlsigpml.model/1.0';

modeltype QVT 		uses 'http://www.eclipse.org/QVT/1.0.0/Operational';
modeltype TimeModel uses 'http://fr.inria.aoste.timemodel';
modeltype FeedBack 	uses 'http://timesquare.inria.fr/feedback';
modeltype Priority  uses 'http://fr.inria.aoste.timesquare.ccslkernel.solver.priorities';

transformation doplatform__resource_org_eclipse_gemoc_example_moccmlsigpml_model_model_sigpml_ecore_To_CCSL(in inM : inMM1, out ccsl : TimeModel, out feedback : FeedBack, out priority: Priority);

property thePrioritySpec		:Priority::PrioritySpecification = null;
property theFeedBackSpec		:FeedBack::ActionModel = null;
property seqOfMSE :	Sequence(FeedBack::ModelSpecificEvent)    = Sequence{};
property theCCSLSpec			:TimeModel::CCSLModel::ClockConstraintSystem = null;
property theMainBlock			:TimeModel::CCSLModel::Block				 = null;
property Kernel_Integer 	: TimeModel::BasicType::Type		= null;
property Kernel_Clock_Type 	: TimeModel::BasicType::Type		= null;
property seqOfRelationDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration)    = Sequence{};
property seqOfAbstractEntity :		Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)    = Sequence{};
property seqOfExpressionDeclaration :	Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration)    = Sequence{};


query identifyUserRelations() {
	var kernelTypes :  	Sequence(TimeModel::BasicType::Type) := Sequence{};
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.example.moccmlsigpml.moc.lib/MoCLib/SigPML.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/org.eclipse.gemoc.example.moccmlsigpml.moc.lib/MoCLib/SigPML.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/org.eclipse.gemoc.example.moccmlsigpml.moc.lib/MoCLib/SigPML.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/org.eclipse.gemoc.example.moccmlsigpml.moc.lib/MoCLib/SigPML.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib")[TimeModel::BasicType::Type];
	seqOfRelationDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::RelationDeclaration];
	seqOfAbstractEntity				+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity];
	seqOfExpressionDeclaration		+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration];
	kernelTypes 					+= getLibObjects("platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib")[TimeModel::BasicType::Type];

	Kernel_Integer 					:= kernelTypes[name='int']->asSequence()->first();
	Kernel_Clock_Type				:= kernelTypes[name='clock']->asSequence()->first();	
	return;
}


//usefull function :)
	mapping Real::Real2Integer(n: String) :TimeModel::BasicType::IntegerElement {
		name:= n;
		type:= Kernel_Integer;
		value := self.round();

		end{
			theMainBlock.elements += result;
		}
	}

main() {
	identifyUserRelations();
	inM.rootObjects()[inMM1::System]->asSequence()->first()-> map sigpml2CCSL();
	inM.rootObjects()[inMM1::System]->asSequence()->first()-> map sigpml2FeedBack();
	inM.rootObjects()[inMM1::System]->asSequence()->first()-> map sigpml2Priority();
	}

			
	mapping inMM1::System::sigpml2CCSL() : TimeModel::CCSLModel::ClockConstraintSystem {
	    theCCSLSpec := result;
	    name := getNameOrUID(self.oclAsType(EObject));
	    theMainBlock :=object TimeModel::CCSLModel::Block{
	    	name := "mainBlock";
	    };
	    subBlock += theMainBlock;
	    result.superBlock := theMainBlock;
		
		var anEmptyBlock :=object TimeModel::CCSLModel::Block{
	    	name := "emptyBlock";
	    };
	    subBlock += anEmptyBlock;
		
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/org.eclipse.gemoc.example.moccmlsigpml.moc.lib/MoCLib/SigPML.ccslLib';
			alias := 'SigPML';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/kernel.ccslLib';
			alias := 'kernel';
			
		}; 
		imports+= object TimeModel::ImportStatement{
			importURI := 'platform:/plugin/fr.inria.aoste.timesquare.ccslkernel.model/ccsllibrary/CCSL.ccslLib';
			alias := 'CCSL';
			
		}; 
	
		imports+= object TimeModel::ImportStatement{
			importURI := getModelPath(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			alias := getModelAlias(inM.rootObjects()->asSequence()->first().oclAsType(EObject));
			
		};

		

		////[ Agent ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map startAgent2Clock();
		////[ Agent ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map stopAgent2Clock();
		////[ Agent ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map isExecuting2Clock();
		


		

		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InputPort.oclAsType(EClass)).oclAsType(InputPort)->map ratePlusOne2Integer();
		////[ InputPort ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InputPort.oclAsType(EClass)).oclAsType(InputPort)->map read2Clock();
		


		

		////[ OutputPort ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), OutputPort.oclAsType(EClass)).oclAsType(OutputPort)->map write2Clock();
		


		

		////[ Place ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map push2Clock();
		////[ Place ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map pop2Clock();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map sizePlusOne2Integer();
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map delayPlusOne2Integer();
		


		

		////[ HWComputationalResource ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map isExecuting2Clock();
		////[ HWComputationalResource ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map idle2Clock();
		


		

		////[ HWStorageResource ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isReading2Clock();
		////[ HWStorageResource ]
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isWriting2Clock();
		


		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map BoundedPlaces32BoundedPlaces();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map TokenConstraint22TokenConstraint();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map waitEnoughData22waitEnoughData();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InputPort.oclAsType(EClass)).oclAsType(InputPort)->map AgentInputConstraint22AgentInputConstraint();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InputPort.oclAsType(EClass)).oclAsType(InputPort)->map portReadInPlace22portReadInPlace();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), OutputPort.oclAsType(EClass)).oclAsType(OutputPort)->map AgentOutputConstraint22AgentOutputConstraint();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), OutputPort.oclAsType(EClass)).oclAsType(OutputPort)->map portWriteInPlace22portWriteInPlace();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map ComputationDelay22ComputationDelay();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map NonReentrantAgent12NonReentrantAgent();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map IsExecutingXorIdle12IsExecutingXorIdle();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map oneAgentAtATime12oneAgentAtATime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map ExecutesItsAllocatedAgents22ExecutesItsAllocatedAgents();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map NonPreemptiveExecution42NonPreemptiveExecution();
		
		

		


		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map IsReadingXorWriting12IsReadingXorWriting();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map oneWriteAtATime12oneWriteAtATime();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isReadingAccordingToPortRead22isReadingAccordingToPortRead();
		
		
		getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isWritingAccordingToPortWrite22isWritingAccordingToPortWrite();
		
	}





//create the expressions...

	mapping inMM1::Place::NwriteInAdvance2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'_DelayFor_NwriteInAdvance';
		type := seqOfExpressionDeclaration->select(rd | rd.name = "DelayFor")->first();

				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID((self.itsOutputPort.oclAsType(OutputPort)).oclAsType(EObject))+'_write']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockToDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID((self.itsOutputPort.oclAsType(OutputPort)).oclAsType(EObject))+'_write']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForClockForCounting' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_sizePlusOne']->first();
					_abstract := seqOfAbstractEntity[name = 'DelayForDelay' and container().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ExpressionDeclaration).name = 'DelayFor']->first();
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::HWComputationalResource::intermediate_allAgentsExecutions2Expression(an1 : Agent, an2 : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentsExecutions'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_isExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_isExecuting']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::HWComputationalResource::intermediate_allAgentsExecutions2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentsExecutions'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_isExecuting']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::HWComputationalResource::allAgentsExecutions2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	
		var sources : Sequence(Agent) := self.allocatedAgents.oclAsType(Agent)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allAgentsExecutions2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allAgentsExecutions2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allAgentsExecutions2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::HWComputationalResource::intermediate_allAgentStops2Expression(an1 : Agent, an2 : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentStops'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_stopAgent']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_stopAgent']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::HWComputationalResource::intermediate_allAgentStops2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentStops'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_stopAgent']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::HWComputationalResource::allAgentStops2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	
		var sources : Sequence(Agent) := self.allocatedAgents.oclAsType(Agent)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allAgentStops2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allAgentStops2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allAgentStops2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::HWComputationalResource::intermediate_allAgentStarts2Expression(an1 : Agent, an2 : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_startAgent']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_startAgent']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::HWComputationalResource::intermediate_allAgentStarts2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : Agent, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allAgentStarts'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_startAgent']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::HWComputationalResource::allAgentStarts2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	
		var sources : Sequence(Agent) := self.allocatedAgents.oclAsType(Agent)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allAgentStarts2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allAgentStarts2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allAgentStarts2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::HWStorageResource::intermediate_allPortReads2Expression(an1 : InputPort, an2 : InputPort, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allPortReads'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_read']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_read']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::HWStorageResource::intermediate_allPortReads2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : InputPort, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allPortReads'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_read']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::HWStorageResource::allPortReads2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	
		var sources : Sequence(InputPort) := self.allocatedPlaces.itsInputPort.oclAsType(InputPort)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allPortReads2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allPortReads2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allPortReads2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}


	
	
//Create an intermediate expression
//create the expressions... 
	mapping inMM1::HWStorageResource::intermediate_allPortWrites2Expression(an1 : OutputPort, an2 : OutputPort, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{ 
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allPortWrites'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
		 			bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_write']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_write']->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}

	mapping inMM1::HWStorageResource::intermediate_allPortWrites2Expression(expr :TimeModel::CCSLModel::ClockExpressionAndRelation::Expression , an : OutputPort, nb : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_allPortWrites'+nb.toString();
		type := seqOfExpressionDeclaration->select(rd | rd.name = "Union")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.expressions[name = expr.name]->first();
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an.oclAsType(EObject))+'_write']->first();
					
					var seqAbstract : Sequence(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity) := seqOfExpressionDeclaration[name = 'Union']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelExpression::Union).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
					seqAbstract := seqAbstract->sortedBy(e | e.name); //just a way to have always the same order ?
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.expressions += result;
		}
	}
	
	mapping inMM1::HWStorageResource::allPortWrites2Expression():TimeModel::CCSLModel::ClockExpressionAndRelation::Expression
	{
		init{

	
		var sources : Sequence(OutputPort) := self.allocatedPlaces.itsOutputPort.oclAsType(OutputPort)->asSequence();
		var lastExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression :=null;
		var i : Integer := 3;
		var newExpr : TimeModel::CCSLModel::ClockExpressionAndRelation::Expression := lastExpr;
		var size : Integer = sources->size(); 
		if(size = 1)then{
			result := self.map intermediate_allPortWrites2Expression(sources->at(1),sources->at(1), 1);
		}else{
			lastExpr := self.map intermediate_allPortWrites2Expression(sources->at(1),sources->at(2), 1);
			while (i <= size){
				newExpr := self.map intermediate_allPortWrites2Expression(lastExpr,sources->at(i), i);
				lastExpr := newExpr;
				i := i + 1;
			};
			result := lastExpr;
		}
		endif;
		}
		
		end{
			theMainBlock.expressions += result;
		}
	}




	 	mapping inMM1::Agent::startAgent2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_startAgent';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "execute")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_startAgent';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Agent::stopAgent2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_stopAgent';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "stop")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_stopAgent';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Agent::isExecuting2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "isExecuting")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
		mapping inMM1::InputPort::ratePlusOne2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_ratePlusOne';
			type:= Kernel_Integer;
			value := self.rate+1;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::InputPort::read2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_read';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "read")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_read';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::OutputPort::write2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_write';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "write")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_write';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::Place::push2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_push';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "push")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_push';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::Place::pop2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_pop';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "pop")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_pop';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM1::Place::sizePlusOne2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_sizePlusOne';
			type:= Kernel_Integer;
			value := self.size+1;

			end{
				theMainBlock.elements += result;
			}
		}
		mapping inMM1::Place::delayPlusOne2Integer() :TimeModel::BasicType::IntegerElement
		 {
			name:= getNameOrUID(self.oclAsType(EObject)) + '_delayPlusOne';
			type:= Kernel_Integer;
			value := self.delay +1;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::HWComputationalResource::isExecuting2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isExecuting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
				//referencedObjectRefs += self.oclAsType(EObject);
				referencedObjectRefs += self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "incCycle")->first().oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isExecuting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::HWComputationalResource::idle2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_idle';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_idle';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		
	 	mapping inMM1::HWStorageResource::isReading2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isReading';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isReading';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}
	 	mapping inMM1::HWStorageResource::isWriting2Clock() :TimeModel::Clock 
		{
			name:= getNameOrUID(self.oclAsType(EObject))+'_isWriting';
			tickingEvent := object TimeModel::Event{
 				referencedObjectRefs += self.oclAsType(EObject);
			
				name := 'evt_'+getNameOrUID(self.oclAsType(EObject))+'_isWriting';
			kind :=TimeModel::EventKind::undefined;
						
			};
			type:= Kernel_Clock_Type;

			end{
				theMainBlock.elements += result;
			}
		}

//relation stuff		

//relation stuff		
	
		mapping inMM1::Place::BoundedPlaces32BoundedPlaces(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.size > 0) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Precedes_BoundedPlaces";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Precedes")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID((self.itsInputPort.oclAsType(InputPort)).oclAsType(EObject))+'_read']->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map NwriteInAdvance2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Precedes']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Place::TokenConstraint22TokenConstraint(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Token_TokenConstraint";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Token")->first();
					var itsDelay : Integer := self.delay;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(((self).itsOutputPort.oclAsType(OutputPort)).oclAsType(EObject))+'_write']->first();
					_abstract := seqOfAbstractEntity[name = 'Token_write']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(((self).itsInputPort.oclAsType(InputPort)).oclAsType(EObject))+'_read']->first();
					_abstract := seqOfAbstractEntity[name = 'Token_read']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self.delay -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_delay")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'Token_delay']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Place::waitEnoughData22waitEnoughData(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"PlaceRate_waitEnoughData";
			type := seqOfRelationDeclaration->select(rd | rd.name = "PlaceRate")->first();
					var itsInputPortRate : Integer := self.itsInputPort.rate;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.itsInputPort.oclAsType(InputPort).oclAsType(EObject))+'_read']->first();
					_abstract := seqOfAbstractEntity[name = 'Place_inputPortread']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_push']->first();
					_abstract := seqOfAbstractEntity[name = 'Place_push']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self.itsInputPort.rate -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.itsInputPort.oclAsType(EObject))+"_rate")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'Place_weightPlusOne']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_delayPlusOne']->first();
					_abstract := seqOfAbstractEntity[name = 'Place_delayPlusOne']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::InputPort::AgentInputConstraint22AgentInputConstraint(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Input_AgentInputConstraint";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Input")->first();
					var itsRate : Integer := self.rate;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.owner.oclAsType(Agent).oclAsType(EObject))+'_startAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'Input_actor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_read']->first();
					_abstract := seqOfAbstractEntity[name = 'Input_read']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_ratePlusOne']->first();
					_abstract := seqOfAbstractEntity[name = 'Input_weightPlusOne']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self.rate -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_rate")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'Input_weight']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::InputPort::portReadInPlace22portReadInPlace(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_portReadInPlace";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var associatedIPlace : Place := self.owner.owner.ownedPlaces->select(p | (p).itsInputPort = self)->first().oclAsType(Place);
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_read']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID((associatedIPlace).oclAsType(EObject))+'_pop']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::OutputPort::AgentOutputConstraint22AgentOutputConstraint(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Output_AgentOutputConstraint";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Output")->first();
					var itsORate : Integer := self.rate;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.owner.oclAsType(Agent).oclAsType(EObject))+'_stopAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'Output_actor']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_write']->first();
					_abstract := seqOfAbstractEntity[name = 'Output_write']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self.rate -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_rate")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'Output_weight']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::OutputPort::portWriteInPlace22portWriteInPlace(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_portWriteInPlace";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
					var associatedOPlace : Place := self.owner.owner.ownedPlaces->select(p | (p).itsOutputPort = self)->first().oclAsType(Place);
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_write']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID((associatedOPlace).oclAsType(EObject))+'_push']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::Agent::ComputationDelay22ComputationDelay(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"AgentExecution_ComputationDelay";
			type := seqOfRelationDeclaration->select(rd | rd.name = "AgentExecution")->first();
					var itsExecTime : Integer := self.cycles;
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'AgentExecution_start']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stopAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'AgentExecution_stop']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isExecuting']->first();
					_abstract := seqOfAbstractEntity[name = 'AgentExecution_refTime']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self.cycles -> map Real2Integer(getNameOrUID(self.oclAsType(EObject))+getNameOrUID(self.oclAsType(EObject))+"_cycles")->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AgentExecution_execTime']->first();
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::Agent::NonReentrantAgent12NonReentrantAgent(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_NonReentrantAgent";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_startAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_stopAgent']->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::HWComputationalResource::IsExecutingXorIdle12IsExecutingXorIdle(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_IsExecutingXorIdle";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_idle']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM1::HWComputationalResource::intermediate_oneAgentAtATime12oneAgentAtATime(an1 : Agent, an2 : Agent, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneAgentAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_isExecuting']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_isExecuting']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM1::HWComputationalResource::oneAgentAtATime12oneAgentAtATime()
	{
		init{
			var sources : Sequence(Agent) := self.allocatedAgents.oclAsType(Agent)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneAgentAtATime12oneAgentAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM1::HWComputationalResource::ExecutesItsAllocatedAgents22ExecutesItsAllocatedAgents(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_ExecutesItsAllocatedAgents";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isExecuting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAgentsExecutions2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::HWComputationalResource::NonPreemptiveExecution42NonPreemptiveExecution(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
			when { 
				(self.isUnderPreemptiveManagement) 
				
}
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Alternates_NonPreemptiveExecution";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Alternates")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAgentStarts2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesLeftClock']->first();
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allAgentStops2Expression()->asSequence()->first();
					_abstract := seqOfAbstractEntity[name = 'AlternatesRightClock']->first();
				};
		
		theMainBlock.relations += result;
		}
		

//relation stuff		
	
		mapping inMM1::HWStorageResource::IsReadingXorWriting12IsReadingXorWriting(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Exclusion_IsReadingXorWriting";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isReading']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isWriting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	

//Create an intermediate relation
	mapping inMM1::HWStorageResource::intermediate_oneWriteAtATime12oneWriteAtATime(an1 : OutputPort, an2 : OutputPort, nbi : Integer, nbj : Integer):TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
	{
		name := getNameOrUID(self.oclAsType(EObject))+'intermediate_oneWriteAtATime'+nbi.toString()+"_"+nbj.toString();
		var seqAbstract : Sequence(Stdlib::Element) := seqOfRelationDeclaration[name = 'Exclusion']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::Exclusion).allSubobjectsOfKind(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity)->asSequence();
		type := seqOfRelationDeclaration->select(rd | rd.name = "Exclusion")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an1.oclAsType(EObject))+'_write']->first();
					_abstract := seqAbstract->at(1).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(an2.oclAsType(EObject))+'_write']->first();
					_abstract := seqAbstract->at(2).oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::AbstractEntity);
				};
		end{
			theMainBlock.relations += result;
		}
	}
	
	mapping inMM1::HWStorageResource::oneWriteAtATime12oneWriteAtATime()
	{
		init{
			var sources : Sequence(OutputPort) := self.allocatedPlaces.itsOutputPort.oclAsType(OutputPort)->asSequence();
			var i : Integer := 1;
			var j : Integer := 1;
			var size : Integer = sources->size(); 
			while (i <= size){
				j := i+1;
				while (j <= size){
					theMainBlock.relations +=  self.map intermediate_oneWriteAtATime12oneWriteAtATime(sources->at(i),sources->at(j), i, j);
					j := j + 1;
				};
				i := i + 1;
			};
		}
	}

		
	
		mapping inMM1::HWStorageResource::isReadingAccordingToPortRead22isReadingAccordingToPortRead(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_isReadingAccordingToPortRead";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isReading']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allPortReads2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		
	
		mapping inMM1::HWStorageResource::isWritingAccordingToPortWrite22isWritingAccordingToPortWrite(): TimeModel::CCSLModel::ClockExpressionAndRelation::Relation
		{
		 	name := getNameOrUID(self.oclAsType(EObject))+"Coincides_isWritingAccordingToPortWrite";
			type := seqOfRelationDeclaration->select(rd | rd.name = "Coincides")->first();
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
					bindable := theMainBlock.elements[name = getNameOrUID(self.oclAsType(EObject))+'_isWriting']->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).leftEntity;
				};
				bindings += object TimeModel::CCSLModel::ClockExpressionAndRelation::Binding{
							bindable := self -> map allPortWrites2Expression()->asSequence()->first();
					_abstract := seqOfRelationDeclaration[name = 'Coincides']->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::KernelRelation::KernelRelationDeclaration).rightEntity;
				};
		
		theMainBlock.relations += result;
		}
		





















mapping inMM1::System::sigpml2FeedBack() : FeedBack::ActionModel {
	    theFeedBackSpec := result;
		importStatements+= object FeedBack::ImportStatement{
			importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
		}; 
		

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map startAgent2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map stopAgent2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map isExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), InputPort.oclAsType(EClass)).oclAsType(InputPort)->map read2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), OutputPort.oclAsType(EClass)).oclAsType(OutputPort)->map write2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map push2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Place.oclAsType(EClass)).oclAsType(Place)->map pop2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map isExecuting2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWComputationalResource.oclAsType(EClass)).oclAsType(HWComputationalResource)->map idle2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isReading2MSE();
	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), HWStorageResource.oclAsType(EClass)).oclAsType(HWStorageResource)->map isWriting2MSE();

}		


	 	mapping inMM1::Agent::startAgent2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_startAgent';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "execute")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_startAgent')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Agent::stopAgent2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_stopAgent';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "stop")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_stopAgent')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Agent::isExecuting2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isExecuting';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "isExecuting")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::InputPort::read2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_read';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "read")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_read')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::OutputPort::write2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_write';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "write")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_write')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Place::push2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_push';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "push")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_push')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::Place::pop2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_pop';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "pop")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_pop')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::HWComputationalResource::isExecuting2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isExecuting';

				caller := self.oclAsType(EObject);
				action := self.oclAsType(EObject).eClass().eAllOperations->select(op |op.name = "incCycle")->first();
				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isExecuting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::HWComputationalResource::idle2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_idle';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_idle')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::HWStorageResource::isReading2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isReading';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isReading')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
	 	mapping inMM1::HWStorageResource::isWriting2MSE() :FeedBack::ModelSpecificEvent 
		{
			name:= 'MSE_'+getNameOrUID(self.oclAsType(EObject))+'_isWriting';

				solverEvent := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isWriting')->first().oclAsType(EObject);
				
			end{
				theFeedBackSpec.events += result;
				seqOfMSE += result
			}
		}
			
		


mapping inMM1::System::sigpml2Priority() : Priority::PrioritySpecification {
	thePrioritySpec := result;
	importedModel := object Priority::ImportStatement{
		importURI := getModelPath(ccsl.objectsOfType(TimeModel::Clock)->asSequence()->first().oclAsType(EObject));
	}; 

	getVeryAllElementsFromResourceSetOf(self.oclAsType(EObject), Agent.oclAsType(EClass)).oclAsType(Agent)->map AgentPrio2Priority();

}		

mapping inMM1::Agent::AgentPrio2Priority() :Priority::PriorityRelation 
		when { 
				(self.name.toString().size() < self.container().oclAsType(Application).ownedAgents->select(a | a  <> self).name.toString().size()->min())
				
		}
		{
			lower  := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(self.oclAsType(EObject))+'_isExecuting')->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ConcreteEntity);
			higher := theMainBlock.elements[TimeModel::Clock]->select(c|c.name=getNameOrUID(
				self.container().oclAsType(Application).ownedAgents->select(a |a.name.toString().size() = self.container().oclAsType(Application).ownedAgents->select(ag | ag  <> self).name.toString().size()->min())->first().oclAsType(EObject))+'_isExecuting')->first().oclAsType(TimeModel::CCSLModel::ClockExpressionAndRelation::ConcreteEntity);
			end{
				thePrioritySpec.relations += result;
			}
		}










