/*
 * generated by Xtext
 */
package org.eclipse.gemoc.execution.moccml.testscenariolang.xtext.serializer;

import com.google.inject.Inject;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.ImportStatement;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.TimeModelPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.EObjectRef;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.ImportJavaStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.IntegerLiteral;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.MseStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.ObjectVariable;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.RewritingRuleCallStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.Scenario;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.StringLiteral;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.TestScenarioLangPackage;
import org.eclipse.gemoc.execution.moccml.testscenariolang.xtext.services.TestScenarioLangGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmAnyTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractTestScenarioLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TestScenarioLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TestScenarioLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TestScenarioLangPackage.EOBJECT_REF:
				sequence_EObjectRef(context, (EObjectRef) semanticObject); 
				return; 
			case TestScenarioLangPackage.IMPORT_JAVA_STATEMENT:
				sequence_ImportJavaStatement(context, (ImportJavaStatement) semanticObject); 
				return; 
			case TestScenarioLangPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case TestScenarioLangPackage.MSE_STATEMENT:
				sequence_MseStatement(context, (MseStatement) semanticObject); 
				return; 
			case TestScenarioLangPackage.OBJECT_VARIABLE:
				sequence_ObjectVariable(context, (ObjectVariable) semanticObject); 
				return; 
			case TestScenarioLangPackage.REWRITING_RULE_CALL_STATEMENT:
				sequence_RewritingRuleCallStatement(context, (RewritingRuleCallStatement) semanticObject); 
				return; 
			case TestScenarioLangPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case TestScenarioLangPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			}
		else if (epackage == TimeModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TimeModelPackage.IMPORT_STATEMENT:
				sequence_ImportStatement(context, (ImportStatement) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_ANY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmAnyTypeReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Variable returns EObjectRef
	 *     EObjectRef returns EObjectRef
	 *
	 * Constraint:
	 *     object=[EObject|QualifiedName]
	 */
	protected void sequence_EObjectRef(ISerializationContext context, EObjectRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestScenarioLangPackage.Literals.EOBJECT_REF__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestScenarioLangPackage.Literals.EOBJECT_REF__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEObjectRefAccess().getObjectEObjectQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(TestScenarioLangPackage.Literals.EOBJECT_REF__OBJECT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImportJavaStatement returns ImportJavaStatement
	 *
	 * Constraint:
	 *     (importedNamespace=QualifiedName | importedNamespace=QualifiedNameWithWildCard)
	 */
	protected void sequence_ImportJavaStatement(ISerializationContext context, ImportJavaStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportStatement returns ImportStatement
	 *
	 * Constraint:
	 *     (importURI=EString (alias=';' | alias=EString))
	 */
	protected void sequence_ImportStatement(ISerializationContext context, ImportStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestScenarioLangPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestScenarioLangPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JvmTypeReference returns JvmAnyTypeReference
	 *
	 * Constraint:
	 *     type=[JvmType|QualifiedName]
	 */
	protected void sequence_JvmTypeReference(ISerializationContext context, JvmAnyTypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.JVM_ANY_TYPE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.JVM_ANY_TYPE_REFERENCE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJvmTypeReferenceAccess().getTypeJvmTypeQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(TypesPackage.Literals.JVM_ANY_TYPE_REFERENCE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MseStatement
	 *     MseStatement returns MseStatement
	 *
	 * Constraint:
	 *     (clocks+=[Clock|ID] clocks+=[Clock|ID]*)
	 */
	protected void sequence_MseStatement(ISerializationContext context, MseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectVariable returns ObjectVariable
	 *
	 * Constraint:
	 *     (name=EString type=JvmTypeReference)
	 */
	protected void sequence_ObjectVariable(ISerializationContext context, ObjectVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestScenarioLangPackage.Literals.OBJECT_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestScenarioLangPackage.Literals.OBJECT_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, TestScenarioLangPackage.Literals.OBJECT_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestScenarioLangPackage.Literals.OBJECT_VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectVariableAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObjectVariableAccess().getTypeJvmTypeReferenceParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RewritingRuleCallStatement
	 *     RewritingRuleCallStatement returns RewritingRuleCallStatement
	 *
	 * Constraint:
	 *     (objectVariable=[ObjectVariable|ID] method=[JvmOperation|ID] (parameters+=Variable parameters+=Variable*)*)
	 */
	protected void sequence_RewritingRuleCallStatement(ISerializationContext context, RewritingRuleCallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         (
	 *             (modelImports+=ImportStatement | classImports+=ImportJavaStatement) 
	 *             modelImports+=ImportStatement? 
	 *             (classImports+=ImportJavaStatement? modelImports+=ImportStatement?)*
	 *         )? 
	 *         (variables+=ObjectVariable variables+=ObjectVariable*)? 
	 *         statementSequence+=Statement+
	 *     )
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TestScenarioLangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TestScenarioLangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
