// automatically generated by Xtext
grammar org.eclipse.gemoc.execution.moccml.testscenariolang.xtext.TestScenarioLang
	with org.eclipse.xtext.common.Terminals

import "http://gemoc.org/moccml/testscenariolang" 
import "http://fr.inria.aoste.timemodel" as TimeModel
import "http://fr.inria.aoste.timemodel.ccslmodel" as CCSLModel
import "http://fr.inria.aoste.timemodel.ccslmodel.clockexpressionandrelation" as ClockExpressionAndRelation
import "https://team.inria.fr/kairos//trace/1.0.0" as trace
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

Scenario returns Scenario:
	{Scenario}
	'Scenario' (name=EString)?
		( ( modelImports+=ImportStatement 
			| classImports+=ImportJavaStatement )
		( modelImports+=ImportStatement | classImports+=ImportJavaStatement )* )?
		( variables+=ObjectVariable ( variables+=ObjectVariable)* )?
		( statementSequence+=Statement)+
		;

ImportStatement returns TimeModel::ImportStatement:
	'importModel'
		importURI=EString
		( alias=';' | 'as' alias=EString ';' )
	;

ImportJavaStatement:
	( 'importClass' importedNamespace=QualifiedName
		| 'importPackage' importedNamespace=QualifiedNameWithWildCard ) ';'
	;

ObjectVariable returns ObjectVariable:
	'Variable'
	name=EString
		':' type=JvmTypeReference
	';';

QualifiedNameWithWildCard :
    QualifiedName '.' '*'
    ;

QualifiedName:
	ID ('.' ID)*
	;

JvmTypeReference returns types::JvmTypeReference:
	{types::JvmAnyTypeReference}
	type=[types::JvmType|QualifiedName]
	;

Statement returns Statement:
	MseStatement /* | RelationBehavior */ | RewritingRuleCallStatement ;

MseStatement returns MseStatement:
	'expect'
	{MseStatement}
		clocks+=[TimeModel::Clock|ID] ('and' clocks+=[TimeModel::Clock|ID])*
	';'?
	;
RewritingRuleCallStatement returns RewritingRuleCallStatement:
	('execute')
	{RewritingRuleCallStatement}
		(objectVariable=[ObjectVariable|ID] '.' method=[types::JvmOperation|ID] ('('  (parameters+=Variable (','parameters+=Variable)*)* ')')? )
		';'? ;

Variable returns Variable:
	/*VariableRef |*/ IntegerLiteral | StringLiteral |EObjectRef
;

EObjectRef returns EObjectRef:
	object=[ecore::EObject|QualifiedName]
;

StringLiteral:
	value=STRING
;

/*VariableRef:
	var=[ObjectVariable|ID]
;*/

IntegerLiteral:
	value=INT
;

EString returns ecore::EString:
	STRING | ID;

FiredStateKind returns trace::FiredStateKind:
	'ticks' | 'doesnot_tick';

EnableStateKind returns trace::EnableStateKind:
	'must_tick' | 'cannot_tick' | 'is_free' | 'is_undetermined'
	;

LiveStateKind returns LiveStateKind:
	'isAlive' | 'isDead' ;

//RelationBehavior returns CodeExecutionModelBehavior:
//	'RelationBehavior'
//	{CodeExecRelationBehavior}
//		( ( 'with' ('variable')? objectVariable=[ObjectVariable|ID]
//			('invoke' | 'call') method=[types::JvmOperation|ID] '()'? )
//		| ( 'execute' objectVariable=[ObjectVariable|ID] '.' method=[types::JvmOperation|ID] '()'? ) )
//		'when' relation=[ClockExpressionAndRelation::Relation|ID] 'is_true' ';'
//	;
	
//AssertionBehavior returns CodeExecutionModelBehavior:
//	'AssertionBehavior'
//	{CodeExecAssertionBehavior}
//		( ('execute' | 'call') objectVariable=[ObjectVariable|ID] '.' method=[types::JvmOperation|ID] '()'? )
//		'when' assertion=[ClockExpressionAndRelation::Relation|ID]
//		(failed ?= 'is_violated' ( 'or' satisfied ?= 'is_satisfied' )?
//			| satisfied ?= 'is_satisfied' ( 'or' failed ?= 'is_violated' )? )
//		';'
//	;


//RewritingRuleCallStatement returns RewritingRuleCallStatement:
//	('execute' | 'call')
//	{MseStatement}
//		( ('execute' | 'call') objectVariable=[ObjectVariable|ID] '.' method=[types::JvmOperation|ID] '()'? )
//		'when' clock=[TimeModel::Clock|ID]
//		( fireState+=FiredStateKind | enableState+=EnableStateKind | liveState+=LiveStateKind )
//			( 'or' ( fireState+=FiredStateKind | enableState+=EnableStateKind | liveState+=LiveStateKind ) )*
//		("->force" "(" clockToForce+=[TimeModel::Clock|ID] ( "," clockToForce+=[TimeModel::Clock|ID])* ")" )? ';' ;

