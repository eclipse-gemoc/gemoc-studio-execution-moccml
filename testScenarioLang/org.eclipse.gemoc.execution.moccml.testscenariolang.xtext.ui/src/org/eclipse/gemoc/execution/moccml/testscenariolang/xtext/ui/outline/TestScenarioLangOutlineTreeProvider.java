/*******************************************************************************
 * Copyright (c) 2017 I3S laboratory, INRIA and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     I3S laboratory and INRIA Kairos - initial API and implementation
 *******************************************************************************/
/*
* generated by Xtext
*/
package org.eclipse.gemoc.execution.moccml.testscenariolang.xtext.ui.outline;

import java.util.function.BinaryOperator;

import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.ImportJavaStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.IntegerLiteral;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.MseStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.ObjectVariable;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.RewritingRuleCallStatement;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.StringLiteral;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.Variable;
import org.eclipse.gemoc.execution.moccml.testscenariolang.model.TestScenarioLang.VariableRef;
import org.eclipse.jface.viewers.StyledString;
import org.eclipse.swt.SWT;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.utils.TextStyle;
import org.eclipse.xtext.ui.label.StylerFactory;

import com.google.inject.Inject;

import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.Clock;
import fr.inria.aoste.timesquare.ccslkernel.model.TimeModel.ImportStatement;



/**
 * customization of the default outline structure
 * 
 */
public class TestScenarioLangOutlineTreeProvider extends DefaultOutlineTreeProvider {
	
	@Inject 
	private StylerFactory stylerFactory;

	protected Object _text(ImportJavaStatement modelElement) {
		String arg = modelElement.getImportedNamespace();
		return "Java import: " + (arg != null ? arg : "<undefined>");
	}
	
	protected boolean _isLeaf(ImportJavaStatement modelElement) {
		return true;
	}
	
	protected Object _text(ImportStatement modelElement) {
		String arg = modelElement.getImportURI();
		return "Imported Model: " + (arg != null ? arg : "<undefined>");
	}
	
	protected boolean _isLeaf(ImportStatement modelElement) {
		return true;
	}
	
	protected Object _text(ObjectVariable modelElement) {
		JvmTypeReference ref = modelElement.getType();
		String typeName = (ref != null ? (ref.getType() != null ? ref.getType().getSimpleName()
																	: "<undefined>")
									: "<undefined>");
		String varName = modelElement.getName();
		StyledString styledString = stylerFactory.createFromXtextStyle( (varName != null ? varName : "<undefined>"), getBoldTextStyle()).append(": ");
			if (typeName != null){
				styledString.append(typeName);
			}else{
				styledString.append("<Undefined>");
			}
			return styledString;
	}
	
	private TextStyle getBoldTextStyle() {
		  TextStyle textStyle = new TextStyle();
		  textStyle.setStyle(SWT.BOLD);
		  return textStyle;
	}
	
	private TextStyle getItalicTextStyle() {
		  TextStyle textStyle = new TextStyle();
		  textStyle.setStyle(SWT.ITALIC);
		  return textStyle;
	}

	protected boolean _isLeaf(ObjectVariable modelElement) {
		return true;
	}
	
	protected Object _text(RewritingRuleCallStatement modelElement) {
		return stylerFactory.createFromXtextStyle("rewriting rule call", getItalicTextStyle());
	}
	
	protected Object _text(MseStatement modelElement) {
		String clocksName = "";
		String sep="";
		for(Clock c : modelElement.getClocks()) {
			clocksName+=sep+c.getName();
			sep=" and ";
		}
		return stylerFactory.createFromXtextStyle("expect MSE: "+clocksName, getItalicTextStyle());
	}
	
	protected boolean _isLeaf(RewritingRuleCallStatement cb) {
		return false;
	}
	
	protected void _createChildren(IOutlineNode parentNode, RewritingRuleCallStatement behavior) {
		if (behavior.getObjectVariable() != null)
			createNode(parentNode, behavior.getObjectVariable());
		if (behavior.getMethod() != null)
			createNode(parentNode, behavior.getMethod());
		if (behavior.getParameters().size() > 0)
			for(Variable p : behavior.getParameters()) {
				createNode(parentNode, p);
			}
	}
	
	
//	protected void _createChildren(IOutlineNode parentNode, MseStatement behavior) {
//		if (behavior.getClocks().size() > 0)
//			createNode(parentNode, behavior.getClocks());
//	}
	
	protected Object _text(JvmOperation method) {
		return method.getSimpleName() + "()";
	}
	
	protected boolean _isLeaf(JvmOperation op) {
		return true;
	}
		
	protected Object _text(Clock clock) {
		return "Clock: " + clock.getName();
	}
	
	protected boolean _isLeaf(Clock clock) {
		return true;
	}
	
	protected Object _text(Variable var) {
		if (var instanceof VariableRef) {
			return _text(((VariableRef) var).getVar());
		}
		if (var instanceof IntegerLiteral) {
			return Integer.toString(((IntegerLiteral) var).getValue())+":int";
		}
		if (var instanceof StringLiteral) {
			return ((StringLiteral) var).getValue()+":String";
		}
		
		return "_";
	}

	
}
